<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>TRIAL ONLY — Калькулятор (MVP) | MT Україна</title>

    <style>
:root{
  --bg:#f4f5fb;
  --panel:rgba(255,255,255,.80);
  --panel2:rgba(255,255,255,.92);
  --text:#020617;
  --text-main:#020617;
  --muted:rgba(2,6,23,.62);
  --border:rgba(148,163,184,.40);
  --border2:rgba(148,163,184,.50);
  --chip:rgba(22,163,74,.10);
  --accent:#16a34a;
  --accent2:#16a34a;
  --shadow:0 18px 45px rgba(15,23,42,.14);
  --radius:22px;
  --radius-sm:14px;
}

.dark-theme{
  --bg:#545c7d;
  --panel:rgba(15,23,42,.65);
  --panel2:rgba(15,23,42,.85);
  --text:#e5e7eb;
  --text-main:#ffffff;
  --muted:rgba(229,231,235,.72);
  --border:rgba(148,163,184,.22);
  --border2:rgba(148,163,184,.32);
  --chip:rgba(34,197,94,.12);
  --accent:#22c55e;
  --accent2:#16a34a;
  --shadow:0 18px 45px rgba(0,0,0,.55);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
    color:var(--text);
    background:
            radial-gradient(
                    1200px 800px at 20% -10%,
                    rgba(34,197,94,.12),
                    transparent 60%
            ),
            radial-gradient(
                    1000px 700px at 80% 110%,
                    rgba(14,165,233,.10),
                    transparent 65%
            ),
            linear-gradient(
                    180deg,
                    #545c7d 0%,
                    #545c7d 100%
            );
    background-attachment: fixed;
}



.page{max-width:1120px;margin:0 auto;padding:28px 16px 44px}

.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:14px;
  padding:14px 18px;border-radius:999px;
  background:var(--panel2);border:1px solid var(--border2);
  box-shadow:0 12px 35px rgba(15,23,42,.18);
  backdrop-filter:blur(10px);
  position:sticky;top:12px;z-index:20;
}
.dark-theme .topbar{box-shadow:0 18px 45px rgba(0,0,0,.45)}

.brand{display:flex;align-items:center;gap:14px;min-width:240px}
.logo{
  width:42px;height:42px;border-radius:14px;
  display:flex;align-items:center;justify-content:center;
  font-weight:800;letter-spacing:.4px;
  background:rgba(239,68,68,.92);color:#fff;
  box-shadow:0 10px 24px rgba(239,68,68,.22);
}
.brand h1{margin:0;font-size:18px;line-height:1.1;color:var(--text-main)}
.brand .sub{margin-top:3px;font-size:12px;color:var(--muted)}
.actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

.btn{
  appearance:none;border:1px solid var(--border2);
  background:rgba(2,6,23,.04);
  color:var(--text);
  padding:10px 14px;border-radius:999px;
  cursor:pointer;font-weight:700;font-size:13px;
  transition:transform .08s ease, background .15s ease, border-color .15s ease;
  text-decoration:none;display:inline-flex;align-items:center;gap:8px;
}
.dark-theme .btn{background:rgba(15,23,42,.12)}
.btn:hover{transform:translateY(-1px);border-color:rgba(34,197,94,.35)}
.btn:active{transform:translateY(0)}
.btn.primary{background:linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%);border-color:transparent;color:#06210f}
.btn.ghost{background:transparent}

.grid{display:grid;grid-template-columns:420px 1fr;gap:18px;margin-top:18px}
@media (max-width: 980px){.grid{grid-template-columns:1fr}.topbar{position:static}}

.card{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
max-width:1090px;margin:18px auto;padding:28px 16px 44px
}
.card h2{margin:0 0 8px 0;font-size:18px;color:var(--text-main)}
.card .cardSub{color:var(--muted);font-size:12.5px;margin-bottom:12px}

label{display:block;color:var(--muted);font-size:12px;font-weight:800;margin:12px 0 6px}
input[type="text"], input[type="tel"], input[type="number"], select{
  width:100%;
  padding:10px 12px;border-radius:14px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.75);
  color:var(--text);
  outline:none;
}
.dark-theme input, .dark-theme select{background:rgba(0,0,0,.18)}
input::placeholder{color:rgba(2,6,23,.35)}
.dark-theme input::placeholder{color:rgba(229,231,235,.45)}

.row2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media (max-width: 520px){.row2{grid-template-columns:1fr}}

.toggles{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
.toggle{display:flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:999px;padding:8px 12px;background:rgba(2,6,23,.03)}
.dark-theme .toggle{background:rgba(0,0,0,.10)}

.chip{display:inline-flex;align-items:center;gap:8px;border-radius:999px;padding:7px 10px;background:rgba(22,163,74,.10);color:var(--text);border:1px solid rgba(22,163,74,.25);font-size:12px}
.dark-theme .chip{background:rgba(34,197,94,.10);border-color:rgba(34,197,94,.25)}
.kpi{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0 0}

.warn{
  padding:10px 12px;border:1px solid rgba(245,158,11,.35);
  border-radius:14px;background:rgba(245,158,11,.10);
  margin-top:10px;color:rgba(2,6,23,.80);
}
.dark-theme .warn{color:rgba(255,255,255,.88)}

.requestCard{
  margin-top:14px;padding:16px;border-radius:var(--radius);
  border:1px solid var(--border);
  background:linear-gradient(135deg, rgba(22,163,74,.10) 0%, rgba(14,165,233,.06) 100%);
}
.dark-theme .requestCard{background:linear-gradient(135deg, rgba(34,197,94,.10) 0%, rgba(14,165,233,.06) 100%)}
.requestCard h3{margin:0 0 6px 0;color:var(--text-main);font-size:16px}
.requestCard p{margin:0 0 10px 0;color:var(--muted);font-size:12.5px}
.mode-row{display:flex;justify-content:space-between;align-items:center;gap:12px;margin:10px 0 8px}
.mode-pill{padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.65);font-size:12px}
.dark-theme .mode-pill{background:rgba(0,0,0,.22)}
.btn-sm{padding:9px 12px;border-radius:999px;font-size:12px}
.contact-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px}
@media (max-width: 980px){.contact-grid{grid-template-columns:1fr}}

table{width:100%;border-collapse:separate;border-spacing:0}
th,td{padding:10px 10px;border-bottom:1px solid var(--border);vertical-align:top}
th{text-align:left;color:var(--muted);font-size:12px;font-weight:900;letter-spacing:.2px}

.spec-wrap{max-height:560px;overflow:auto;border-radius:16px;border:1px solid var(--border)}
.spec-table{width:100%;table-layout:auto;min-width:860px}
.spec-table td:nth-child(4), .spec-table th:nth-child(4){
  /*width:420px;min-width:360px;*/
  white-space:normal;word-break:break-word;overflow-wrap: break-word;line-height:1.25;
}
.spec-table td:nth-child(1), .spec-table th:nth-child(1){min-width:150px}
/*.spec-table td:nth-child(2), .spec-table th:nth-child(2){min-width:260px}*/
.spec-table td:nth-child(3), .spec-table th:nth-child(3){min-width:130px}
.spec-table td:nth-child(5), .spec-table th:nth-child(5){min-width:110px;text-align:right}
.spec-table td:nth-child(6), .spec-table th:nth-child(6){min-width:120px;text-align:right}
@media (max-width: 980px){.spec-table{min-width:980px}}

/* Responsive cut/pay column */
.cutHead{min-width:320px;white-space:normal}
.cutCell{min-width:320px;white-space:normal;line-height:1.25}
.cutMobile{display:none;margin-top:6px}
.small{font-size:12px}
@media (max-width: 980px){
  th.cutHead, td.cutCell{display:none;}
  .cutMobile{display:block;}
}


/* Layout ordering: 2-column tech, then request, then spec */
.topGrid{grid-template-columns: 1fr 1fr; align-items:start;}
@media (max-width: 980px){.topGrid{grid-template-columns:1fr;}}
.card.requestCard{max-width:1090px;margin:0 auto;padding:28px 16px 44px}
/*.card + .card{margin-top:18px;}*/
</style>
</head>

<body>
<div class="page">
    <div class="topbar">
        <div class="brand">
            <div class="logo">MT</div>
            <div>
                <h1>TRIAL ONLY — Калькулятор (MVP)</h1>
                <div class="sub">Каркас / Вітрина / LED · без IKS (LAIT — лише як тип полиць для ліміту W)</div>
            </div>
        </div>
        <div class="actions">
            <a class="btn ghost" href="only.html">← Назад до ONLY</a>
            <button class="btn" id="themeToggle">Тема</button>
        </div>
    </div>

    <div class="grid topGrid">
<div class="card">
            <div class="cardHead">
                <div class="cardTitle">Параметри модуля</div>
            </div>
            <div class="cardBody">
                <div class="row">
                    <div>
                        <label for="H">Висота H (мм)</label>
                        <input id="H" type="number" min="300" step="1" value="2200">
                    </div>
                    <div>
                        <label for="W">Ширина W (мм)</label>
                        <input id="W" type="number" min="300" step="1" value="1200">
                    </div>
                </div>

                <div style="margin-top:10px;">
                    <label for="D">Глибина D (мм)</label>
                    <input id="D" type="number" min="200" step="1" value="450">
                    <div class="small muted" style="margin-top:6px;">
                        D зараз довідково (специфікація каркаса рахується по H та W).
                    </div>
                </div>

                <div style="margin-top:10px;">
                    <label for="trimEachSide">Торцювання з кожного боку (мм)</label>
                    <input id="trimEachSide" type="number" min="0" max="120" step="1" value="60">
                    <div class="small muted" style="margin-top:6px;">
                        Торцюємо <b>палки</b> (корисна довжина = 6100 − 2×торцювання). Деталі не “коротимо”.
                    </div>
                </div>
                <div style="margin-top:10px;">
                    <label for="eurRateInput">Курс EUR → грн</label>
                    <input id="eurRateInput" type="number" min="1" step="0.1" value="50.0">

                </div>


                <div style="margin-top:10px;">
                    <label for="colorCode">Колір профілю</label>
                    <select id="colorCode" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="NS">Чорний мат</option>
                        <option value="BRA">Бронза Armani</option>
                        <option value="BRC">Бронза Cartier</option>
                    </select>
                </div>

                <div style="margin-top:10px;">
                    <label for="shelfType">Тип полиць</label>
                    <select id="shelfType" style="width:100%;padding:10px 12px;border-radius:12px;">
<!--                        <option value="chipboard" selected>Полиці ДСП/МДФ (робоча ширина 600–900 мм)</option>-->
                        <option value="lait">Полиці LAIT (Lite) (робоча ширина 600–1000 мм)</option>
                    </select>

                    <div id="wRangeWarn" class="warn small" style="display:none;margin-top:8px;"></div>
                    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                        <button type="button" id="openLaitBtn" class="btn">
                            Розрахувати полиці LAIT
                        </button>
                        <div class="small muted" id="laitHint" style="align-self:center;"></div>
                    </div>

                </div>

                <div style="margin-top:10px;">
                    <label for="shelvesCount">Кількість полиць (шт)</label>
                    <input id="shelvesCount" type="number" min="0" max="12" step="1" value="0">
                    <div class="small muted" style="margin-top:6px;">
                        Горизонталі OL-965 = 2 (верх/низ) + N полиць. Зʼєднувачі OL-GTSI = 2 шт.
                    </div>
                </div>

                
            </div>
        </div>
<div class="card">
            <div class="cardHead">
                <div class="cardTitle">Панелі, скло, LED</div>
                <div class="cardSub">Панелі (25 мм), бокове/заднє скло та LED.</div>
            </div>
            <div class="cardBody"><div class="field" style="margin-top:10px;">
                    <label class="toggle">
                        <input id="topBottom25" type="checkbox" checked>
                        Дно + кришка (ДСП/МДФ 25 мм) — кріплення Permo
                    </label>
                    <div class="small muted" style="margin-top:6px;">
                        Рахуємо площу 2 панелей (W×D) та комплект кріплення Permo для кожної рамки (4 точки на панель).
                    </div>
                </div>

                <div class="field" style="margin-top:10px;">
                    <label class="toggle">
                        <input id="frameMode" type="checkbox">
                        Режим рамок (прольоти по ширині)
                    </label>
                    <div class="small muted" style="margin-top:6px;">
                        Розбиваємо загальну ширину W на прольоти: ДСП ≤900 мм, LAIT ≤1000 мм. Рамок = прольоти + 1.
                    </div>
                </div>

                <div style="margin-top:10px;">
                    <label for="sideGlass">Скло в боковинах</label>
                    <select id="sideGlass" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="none" selected>Нема</option>
                        <option value="left">Ліва боковина (скло в паз)</option>
                        <option value="right">Права боковина (скло в паз)</option>
                        <option value="both">Обидві боковини (скло в паз)</option>
                    </select>
                <div style="margin-top:10px;">
                    <label for="glassSupplier">Постачальник скла</label>
                    <select id="glassSupplier" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="ABSTRACT" selected>Варіант A</option>
                        <option value="BUSEL">Варіант B</option>
                    </select>
                </div>

                <div id="abstractGlassSelectors" style="margin-top:10px;">
                    <label for="abstractSideGlassId">Варіант A: скло для боковин (4 мм)</label>
                    <select id="abstractSideGlassId" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="ABS_FLOAT_4" selected>Float 4 мм</option>
                        <option value="ABS_DIAMOND_4">Діамант / Extra Clear 4 мм</option>
                        <option value="ABS_GRAPHITE_4">Графіт 4 мм</option>
                        <option value="ABS_BRONZE_4">Бронза 4 мм</option>
                    </select>
                </div>

                <div id="buselSideWrap" style="margin-top:10px;">
                    <label for="buselSideGlassId">Варіант B: скло для боковин (4 мм)</label>
                    <select id="buselSideGlassId" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="BUSEL_FLOAT_CLEAR_4_RIZKA" selected>Float Clear 4 мм</option>
                        <option value="BUSEL_ULTRACLEAR_4_RIZKA">UltraClear 4 мм</option>
                        <option value="BUSEL_CHINA_DARKGREY_4_RIZKA">DarkGrey 4 мм</option>
                        <option value="BUSEL_PLANIBEL_BRONZE_GREY_4_RIZKA">Planibel Bronze Grey 4 мм</option>
                    </select>
<!--                </div>-->
<!--                    <select id="buselSideGlassId" style="width:100%;padding:10px 12px;border-radius:12px;">-->
<!--                        <option value="BUSEL_FLOAT_CLEAR_4_RIZKA" selected>Float Clear 4 мм</option>-->
<!--                        <option value="BUSEL_ULTRACLEAR_4_RIZKA">UltraClear 4 мм</option>-->
<!--                        <option value="BUSEL_CHINA_DARKGREY_4_RIZKA">DarkGrey 4 мм</option>-->
<!--                        <option value="BUSEL_PLANIBEL_BRONZE_GREY_4_RIZKA">Planibel Bronze Grey 4 мм</option>-->
<!--                    </select>-->
<!--                </div>-->

                </div>

                <div class="toggles">
                    <label for="backPanelType">Тип задньої стінки</label>
                    <select id="backPanelType" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="none">Нема (глухий каркас)</option>
                        <option value="opaque8">Непрозоре 8 мм (MDF/HDF) — без ущільнювача</option>
                        <option value="glass6" selected>Скло 6 мм (в паз) — з ущільнювачем GU-C-RG</option>
                    </select>
                <div class="toggles" style="margin-top:10px;">
                    <div id="abstractBackWrap" class="toggles" style="margin-top:10px;">
                    <label for="abstractBackGlassId">Варіант A: скло для спинки (6 мм)</label>
                    <select id="abstractBackGlassId" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="ABS_FLOAT_6" selected>Float 6 мм</option>
                        <option value="ABS_DIAMOND_6">Діамант / Extra Clear 6 мм</option>
                        <option value="ABS_GRAPHITE_6">Графіт 6 мм</option>
                        <option value="ABS_BRONZE_6">Бронза 6 мм</option>
                    </select>
                </div>

                <div id="buselBackWrap" class="toggles" style="margin-top:10px;">
                    <label for="buselBackGlassId">Варіант B: скло для спинки (6 мм)</label>
                    <select id="buselBackGlassId" style="width:100%;padding:10px 12px;border-radius:12px;">
                        <option value="BUSEL_CHINA_FLOAT_CLEAR_6_RIZKA" selected>Float Clear 6 мм</option>
                        <option value="BUSEL_ULTRACLEAR_6_RIZKA">UltraClear 6 мм</option>
                        <option value="BUSEL_CHINA_DARKGREY_6_RIZKA">DarkGrey 6 мм</option>
                        <option value="BUSEL_CHINA_BRONZE_6_RIZKA">Bronze 6 мм</option>
                    </select>
                </div>

                    <label class="toggle">
                        <input id="isLed" type="checkbox">
                        LED (передня вертикаль)
                    </label>
                </div>

                <div class="warn small">
                    ⚠️ Електрика LED не рахуються. IKS/LAIT — окремо.<br/>
                </div>

                   
                    
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
  <button class="btn primary" id="btnCalc">Розрахувати</button>
  <button class="btn" id="btnCsv">Завантажити CSV</button>
</div>
            </div>
        </div>

        
            </div>
        </div>
</div>

<div class="card requestCard">
  <h3 style="margin:0 0 6px 0;">Орієнтовна вартість + заявка</h3>
  <div class="small muted">Після «Розрахувати» сума оновиться, далі можна одразу надіслати в Telegram.</div>

  <div class="mode-row">
    <div class="mode-pill" id="currentModeLabel">Режим: клієнт</div>
    <button class="btn btn-sm" id="managerToggleBtn" type="button">Менеджер</button>
  </div>

  <div class="contact-grid">
    <div>
      <div class="small muted">Імʼя</div>
      <input id="contactFirstName" placeholder="Імʼя">
    </div>
    <div>
      <div class="small muted">Прізвище</div>
      <input id="contactLastName" placeholder="">
    </div>
    <div>
      <div class="small muted">Телефон</div>
      <input id="contactPhone" placeholder="0XXXXXXXXX">
    </div>
  </div>

  <button class="btn primary" style="margin-top:12px;" id="sendToTelegramBtn" type="button">
    Надіслати заявку в MT × Systems
  </button>
  <div class="small muted" style="margin-top:8px;">В менеджер-режимі видно повну специфікацію.</div>
</div>

<div class="card">
            <div class="cardHead">
                <div class="cardTitle">Специфікація</div>
                <div class="cardSub">Порізка по палках + оплата 0.5/1 + сума €.</div>
            </div>
            <div class="cardBody">
                <div class="kpi" id="kpi"></div>

                <div style="overflow:auto;margin-top:10px;">
                    <div class="spec-wrap"><table id="tbl" class="spec-table"><colgroup><col style="width:160px"><col style="width:280px"><col style="width:140px"><col style="width:420px"><col style="width:120px"><col style="width:130px"></colgroup>
                        <thead>
                        <tr>
                            <th>Код</th>
                            <th>Найменування</th>
                            <th>Деталі</th>
                            <th class="cutHead">Порізка / Оплата</th>
                            <th>Ціна (€)</th>
                            <th>Сума (€)</th>
                        </tr>
                        </thead>
                        <tbody></tbody>
                    </table></div>
                </div>

                <div class="small muted" style="margin-top:10px;">
                    BAR-рядки рахуються як: <b>ціна палки × (0.5 або 1)</b> по кожній палці, на основі фактичного використання.
                </div>
            </div>
        </div>
</div>

<script src="./glass-engine.busel.v3.js"></script>
<script>
  // ===== Busel v3 config (ONLY) =====
  // Ціни (materialPricePerM2UAH_4/6, temperTariffPerM2UAH_4/6, edgePolishPerMUAH) заповнимо після звірки прайсу.
  if (window.GlassEngine && typeof GlassEngine.setBuselConfig === "function") {
    GlassEngine.setBuselConfig({
      tempered: true,
      eurRate: 50.0,
      minAreaM2: 0.25,
      temperMinFloatUAH: 750,
      temperMinOtherUAH: 999,
      mtDiscount: 0.85,
      mtMarkup: 1.30,
      applySizeSurcharge: false,

      materialPricePerM2UAH_4: 0,
      materialPricePerM2UAH_6: 0,
      temperTariffPerM2UAH_4: 0,
      temperTariffPerM2UAH_6: 0,
      edgePolishPerMUAH: 0
    });
  }
</script>
<script>
    // ===== Busel price list (UAH) =====
    let BUSEL = null;

    async function loadBusel() {
        if (BUSEL) return BUSEL;
        const res = await fetch('./only.busel.glass.v1.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`Busel JSON HTTP ${res.status}`);
        BUSEL = await res.json();
        return BUSEL;
    }

    // ===== AbstractGlass price list (UAH) =====
    let ABSTRACT = null;

    async function loadAbstract() {
        if (ABSTRACT) return ABSTRACT;
        const res = await fetch('./only.abstract.glass.v1.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`AbstractGlass JSON HTTP ${res.status}`);
        ABSTRACT = await res.json();
        return ABSTRACT;
    }

    function abstractFindGlassItem(abs, id){
        return abs?.glass_items?.find(x => x.id === id) || null;
    }

    function abstractEdgePolishPerLm(abs, thicknessMm){
        const map = abs?.services?.edge_polish?.pricePerLm_uah || {};
        return (thicknessMm === 6) ? (map.THK_6 || 0) : (map.THK_3_4_5 || 0);
    }

    function abstractTemperingPerM2(abs, thicknessMm){
        const map = abs?.services?.tempering?.pricePerM2_uah || {};
        if (thicknessMm === 4) return map.THK_4 || 0;
        if (thicknessMm === 5) return map.THK_5 || 0;
        if (thicknessMm === 6) return map.THK_6 || 0;
        return 0;
    }

    function abstractMarkup(abs){
        return Number(abs?.commercial_rules?.abstract_markup_multiplier || 1.15) || 1.15;
    }

    function perimeterM(wMm, hMm){
        return (2 * ((Number(wMm)||0) + (Number(hMm)||0))) / 1000;
    }

    function calcAbstractForPanel({ wMm, hMm, qty, thicknessMm, glassItemId, abs }){
        const absData = abs || ABSTRACT;
        if (!absData) return null;
        const item = abstractFindGlassItem(absData, glassItemId);
        if (!item) return null;

        const q = Math.max(1, Math.floor(Number(qty)||1));
        const area = Math.max(0, (Number(wMm)||0) * (Number(hMm)||0)) / 1e6; // m² per piece
        const totalArea = area * q;
        const edgeLm = perimeterM(wMm, hMm) * q;

        const matUAH = totalArea * (Number(item.pricePerM2_uah)||0);

        const edgeUAH = edgeLm * abstractEdgePolishPerLm(absData, thicknessMm);

        // AbstractGlass: tempering modeled as separate service; for ONLY беремо як tempered=ON
        const tempUAH = totalArea * abstractTemperingPerM2(absData, thicknessMm);

        const netUAH = (matUAH + edgeUAH + tempUAH) * abstractMarkup(absData);

        return {
            q, areaPerPiece: area, totalArea, edgeLm,
            matUAH, edgeUAH, tempUAH, netUAH,
            item
        };
    }

    // ===== Glass supplier UI =====
    function updateGlassSupplierUI(){
        const supSel = document.getElementById("glassSupplier");
        const sup = supSel ? supSel.value : "ABSTRACT";
        const absA = document.getElementById("abstractGlassSelectors");
        const absB = document.getElementById("abstractBackWrap");
        const busA = document.getElementById("buselSideWrap");
        const busB = document.getElementById("buselBackWrap");
        if (absA) absA.style.display = (sup === "ABSTRACT") ? "" : "none";
        if (absB) absB.style.display = (sup === "ABSTRACT") ? "" : "none";
        if (busA) busA.style.display = (sup === "BUSEL") ? "" : "none";
        if (busB) busB.style.display = (sup === "BUSEL") ? "" : "none";
    }


    function buselFindGlassItem(busel, id){
        return busel?.glass_items?.find(x => x.id === id) || null;
    }

    function buselEdgePolishPerLm(busel, thicknessMm){
        const map = busel?.services?.edge_polish?.pricePerLm_uah || {};
        return thicknessMm === 4 ? (map.THK_4 || 0) : (map.THK_3_5_6 || 0);
    }

    function buselTemperingTariffPerM2(busel, temperGroup){
        const base = busel?.services?.tempering?.base_pricePerM2_uah || {};
        return base[temperGroup] || 0;
    }



    // ====== theme ======
    const body = document.body;
    const themeBtn = document.getElementById('themeToggle');
    if (localStorage.getItem('theme') === 'dark') body.classList.add('dark-theme');
    themeBtn.addEventListener('click', () => {
        body.classList.toggle('dark-theme');
        localStorage.setItem('theme', body.classList.contains('dark-theme') ? 'dark' : 'light');
    });

    // ====== data ======
    let DB = null;
    async function loadDB() {
        if (DB) return DB;

        const candidates = [
            './only.data.json',      // основний файл у проєкті

        ];

        let lastErr = null;
        for (const url of candidates) {
            try {
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json(); // тут впаде, якщо файл невалідний JSON
                if (!data || !Array.isArray(data.items)) throw new Error('Невірний формат прайсу (немає items).');
                DB = data;
                return DB;
            } catch (e) {
                lastErr = e;
            }
        }
        throw new Error('Не можу завантажити прайс ONLY (only.data.json). Перевір: 1) файл поруч з HTML, 2) валідний JSON, 3) назва без помилок. ' + (lastErr ? ('(' + lastErr.message + ')') : ''));
    }
    function getItemByIdOrCode(db, key) {
        return db.items.find(x => x.id === key || x.code === key) || null;
    }
    // Safe money formatter (prevents NaN in UI if a price is missing/undefined)
    function eur(v){
      const n = Number(v);
      if (!Number.isFinite(n)) return "0.00";
      return (Math.round(n * 100) / 100).toFixed(2);
    }

    // Read EUR price from different schema variants (price.eur, price_eur, eur, etc.)
    function eurPrice(item){
      if (!item) return 0;
      const v = (item.price && (item.price.eur ?? item.price.EUR)) ?? item.price_eur ?? item.priceEUR ?? item.eur ?? item.EUR;
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }


    // ====== BAR CUTTING (FFD) ======
    function packCutsFFD(cuts, barLenEff, kerfMm = 0) {
        const sorted = [...cuts].sort((a,b) => b - a);
        const bars = []; // { used:number, cuts:number[] }

        for (const len of sorted) {
            let placed = false;
            for (const bar of bars) {
                const extra = (bar.cuts.length > 0) ? kerfMm : 0;
                if (bar.used + extra + len <= barLenEff) {
                    bar.used += extra + len;
                    bar.cuts.push(len);
                    placed = true;
                    break;
                }
            }
            if (!placed) bars.push({ used: len, cuts: [len] });
        }

        const detailed = bars.map((b, idx) => ({
            index: idx + 1,
            cuts: b.cuts,
            used: b.used,
            offcut: barLenEff - b.used
        }));

        return {
            barLenEff,
            kerfMm,
            bars: detailed,
            barsCount: detailed.length,
            offcutTotal: detailed.reduce((s, b) => s + b.offcut, 0),
            usedTotal: detailed.reduce((s, b) => s + b.used, 0),
        };
    }

    function paymentUnitsForPlan(plan) {
        // 0.5 якщо використано <= половини корисної довжини, інакше 1.0
        const half = plan.barLenEff / 2;
        let pay = 0;
        for (const b of plan.bars) pay += (b.used <= half ? 0.5 : 1.0);
        return pay;
    }

    function formatCutPlanWithPay(plan) {
        const half = plan.barLenEff / 2;
        const parts = plan.bars.map(b => {
            const pay = (b.used <= half ? 0.5 : 1.0);
            const cutsStr = b.cuts.join("+");
            return `Палка #${b.index}: ${cutsStr} = ${b.used} мм; залишок ${b.offcut} мм; оплата ${pay}`;
        });
        return parts.join(" | ");
    }

    function mapProfileIdByColor(baseId, colorCode) {
        if (colorCode === "NS") return baseId;

        const colorMap = {
            "OL-2545": {
                "BRA": "OL-2545_BRA",
                "BRC": "OL-2545_BRC"
            },
            "OL-965": {
                "BRA": "OL-965_BRA",
                "BRC": "OL-965_BRC"
            }
        };

        return colorMap[baseId]?.[colorCode] || baseId;
    }

    // ====== build spec ======
    function buildSpec(db, opts) {
        const { H, W, D, backPanelType, isLed, trimEachSide, colorCode, shelfType, shelvesCount, sideGlass, glassSupplier, abstractSideGlassId, abstractBackGlassId, buselBackGlassId, buselSideGlassId, eurRate, abstract, frameMode, topBottom25, busel } = opts;
        const EUR_RATE = (Number(eurRate) && Number(eurRate)>0) ? Number(eurRate) : 50.0;
        const barLen = db.defaults?.bar_length_mm || 6100;
        const kerfMm = 0; // фіксуємо 0, щоб не плодити помилки

        const barLenEff = barLen - 2 * trimEachSide;
        if (barLenEff <= 0) throw new Error("Торцювання занадто велике — немає корисної довжини палки.");


        // Обмеження кольорів у MVP: OL-2545L та OL-2545RG доступні лише в чорному мат (NS).
        // Якщо обрано інший колір — базові профілі фарбуємо, але LED/RG залишаємо NS та показуємо попередження.
        const colorWarnings = [];
        const colorSafe = (colorCode === "NS");

        // Vertical types
        const baseVert = "OL-2545";
        const baseHor  = "OL-965";

// LED / RG тільки NS
        const frontVertId = isLed
            ? "OL-2545L"
            : mapProfileIdByColor(baseVert, colorCode);

        const rearVertId = (backPanelType !== "none")
            ? "OL-2545RG" // якщо є задня стінка (скло або непрозоре) — беремо профіль з пазом
            : mapProfileIdByColor(baseVert, colorCode);

        const horId = mapProfileIdByColor(baseHor, colorCode);

        if (!colorSafe && isLed) colorWarnings.push("LED-профіль OL-2545L доступний лише в чорному (NS).");
        if (!colorSafe && backPanelType !== "none") colorWarnings.push("Профіль з пазом OL-2545RG доступний лише в чорному (NS).");

        const items = [];
        // ===== Busel v3 helpers (ONLY) =====
        function findRowByKey(key){
            return items.find(r => r.id === key || r.code === key);
        }
        function setRowPriceByCode(key, priceEur, sumEur, extraNote){
            const r = findRowByKey(key);
            if (!r) return;
            r.priceEur = Number(priceEur) || 0;
            r.sumEur   = Number(sumEur)   || 0;
            if (extraNote){
                r.note = (r.note ? (r.note + " | ") : "") + String(extraNote);
            }
        }
        function calcBuselForPanel({ wMm, hMm, qty, thicknessMm, glassItemId, temperMinType="float" }){
            if (!window.GlassEngine || typeof GlassEngine.calcBuselV3Piece !== "function") return null;
            if (!busel) return null;

            const cfg = GlassEngine.BUSEL_CFG || {};
            const eurRate = Number(cfg.eurRate) || 50.0;

            const item = buselFindGlassItem(busel, glassItemId);
            if (!item) throw new Error(`Busel: не знайдено glass_item id=${glassItemId}`);

            const edgePolishPerMUAH = buselEdgePolishPerLm(busel, Number(thicknessMm)); // UAH/пог.м
            const temperTariffPerM2UAH = buselTemperingTariffPerM2(busel, item.tempering_group); // UAH/м²

            const breakdown = GlassEngine.calcBuselV3Piece({
                widthMm: wMm,

                heightMm: hMm,
                thicknessMm: Number(thicknessMm),
                qty: Number(qty) || 0,
                tempered: true,

                materialPricePerM2UAH: Number(item.pricePerM2_uah) || 0,
                edgePolishPerMUAH: Number(edgePolishPerMUAH) || 0,
                temperTariffPerM2UAH: Number(temperTariffPerM2UAH) || 0,
                temperMinType,

                // min bill / MT coefficients
                minAreaM2: Number(cfg.minAreaM2) || 0.25,
                temperMinFloatUAH: Number(cfg.temperMinFloatUAH) || 750,
                temperMinOtherUAH: Number(cfg.temperMinOtherUAH) || 999,
                mtDiscount: Number(cfg.mtDiscount) || 1,
                mtMarkup: Number(cfg.mtMarkup) || 1,
                applySizeSurcharge: !!cfg.applySizeSurcharge
            });

            breakdown._eurRate = eurRate;
            return breakdown;
        }

        function addRow(itemId, qty, pieceLenMm=null, extra={}) {
            const it = getItemByIdOrCode(db, itemId);
            if (!it) throw new Error(`Немає позиції в only.data.json: ${itemId}`);
            items.push({
                id: it.id || itemId,
                code: it.code || it.id || itemId,
                name: it.name_ua || it.name || extra.name || (it.code || it.id || itemId),
                qtyPieces: qty,
                unit: it.unit || extra.unit || "шт",
                pieceLenMm,
                sell_type: it.sell_type || it.sellType || extra.sell_type || "PCS",
                priceEur: eurPrice(it),
                cutInfo: null,
                qtyPay: null,
                sumEur: null,
                bars: null,
                offcut: null,
                group: extra.group,
                note: extra.note
            });
        }
        // ===== counts (MVP-2) =====
        const nShelves = Math.max(0, Math.floor(Number(shelvesCount || 0)));

        // Frame-mode: W розбиваємо на прольоти, рамок = прольоти + 1.
        const wRange = getWRange(shelfType);
        const spanMax = wRange.max; // 900 (ДСП) або 1000 (LAIT)

        const numSpans  = frameMode ? Math.max(1, Math.ceil(W / spanMax)) : 1;
        const numFrames = frameMode ? (numSpans + 1) : 2; // базовий модуль без рамок = 2 рамки
        const spanW     = Math.ceil(W / numSpans);        // ширина одного прольоту (≈ довжина перемички)

        // Вертикалі (на рамку: 1 передня + 1 задня)
        if (frameMode) {
            addRow(frontVertId, numFrames, H);
            addRow(rearVertId,  numFrames, H);
        } else {
            // базовий MVP-2: 4 вертикалі
            addRow(frontVertId, 2, H);
            addRow(rearVertId,  2, H);
        }

        // Горизонталі (перемички)
        let nHor;
        if (frameMode) {
            // На кожну рамку: 2 (верх/низ) + N полиць
            nHor = (2 + nShelves) * numFrames;
            addRow(horId, nHor, spanW);
        } else {
            // базовий MVP-2: 2 (верх/низ) + N полиць (на модуль)
            nHor = 2 + nShelves;
            addRow(horId, nHor, W);
        }

        // Опори (по 1 на вертикаль)
        const legs = frameMode ? (2 * numFrames) : 4;
        addRow("OL-P", legs, null);

        // З’єднувачі: 2 шт на 1 горизонталь
        addRow("OL-GTSI", 2 * nHor, null);

        // Кріплення задньої стінки (якщо вона є)
        if (backPanelType !== "none") {
            // OL-V — норма 8 шт на 1 модуль (MVP-2). Для frame-mode поки залишаємо як MVP (без масштабування).
            addRow("OL-V_A11.034", 8, null);
            addRow("VITE-TSP-M4X10", 8, null);

            // Ущільнювач тільки якщо скло 6 мм в паз
            if (backPanelType === "glass6") {
                const gasketPcs = Math.ceil((numFrames * 2 * H) / 3000); // numFrames задніх стійок; ущільнювач з 2 сторін; LISTA 3000 мм
                addRow("GU-C-RG-LISTA", gasketPcs, null);
            }
        } else {
            // Якщо задньої стінки немає — базовий набір гвинтів (MVP-2)
            addRow("VITE-TSP-M4X10", 4, null);
        }

        // Заглушки GU-O-F: 2 LISTA (3000 мм) на 1 вертикаль (2 пази)
        const plugs = frameMode ? (4 * numFrames) : 8;
        addRow("GU-O-F-LISTA", plugs, null);

        // ====== ATTACHED MATERIALS (MVP-3+) ======
        // Каталог ONLY:
        // 1) Бокове скло 4 мм: L_fianco - 3.5 мм | H_montante = H_vetro
        // 2) Спинка: H = H_montante - 38 мм
        //    - дерево 8 мм: L_vano + 16 мм
        //    - скло 6 мм:  L_vano + 11 мм
        // Правило: якщо frameMode ON — і спинка, і боковини рахуються ПО СЕКЦІЯХ (vano) окремо.

        // KPI areas (catalog-based)
        let rearAreaM2 = 0;
        let sideAreaM2 = 0;

        // helper: fallback row if SKU missing (price=0) so spec won't break
        function addFallback(code, name, qty, unit, group, note){
            items.push({
                id: code,
                code,
                name,
                qtyPieces: qty,
                unit: unit || "шт",
                pieceLenMm: null,
                sell_type: "VIRTUAL",
                priceEur: 0,
                cutInfo: "—",
                qtyPay: qty,
                sumEur: 0,
                bars: null,
                offcut: null,
                group: group || "ATTACHED",
                note
            });
        }

        function addMaterialM2(itemKey, qtyM2, fallbackName, note){
            const it = getItemByIdOrCode(db, itemKey);
            if (it){
                const pu = eurPrice(it);
                items.push({
                    id: it.id || itemKey,
                    code: it.code || it.id || itemKey,
                    name: it.name_ua || it.name || fallbackName,
                    qtyPieces: qtyM2,
                    unit: it.unit || "м²",
                    pieceLenMm: null,
                    sell_type: it.sell_type || it.sellType || "PCS",
                    priceEur: pu,
                    cutInfo: "—",
                    qtyPay: qtyM2,
                    sumEur: qtyM2 * pu,
                    bars: null,
                    offcut: null,
                    group: it.group || "PANELS",
                    note
                });
            } else {
                addFallback(itemKey, fallbackName || itemKey, qtyM2, "м²", "PANELS",
                    (note || "") + " (позиція/ціна не знайдена в only.data.json)");
            }
        }

        function addMaterialPCS(itemKey, qty, fallbackName, note, groupOverride){
            const it = getItemByIdOrCode(db, itemKey);
            if (it){
                const pu = eurPrice(it);
                items.push({
                    id: it.id || itemKey,
                    code: it.code || it.id || itemKey,
                    name: it.name_ua || it.name || fallbackName,
                    qtyPieces: qty,
                    unit: it.unit || "шт",
                    pieceLenMm: null,
                    sell_type: it.sell_type || it.sellType || "PCS",
                    priceEur: pu,
                    cutInfo: "—",
                    qtyPay: qty,
                    sumEur: qty * pu,
                    bars: null,
                    offcut: null,
                    group: groupOverride || it.group || "ONLY",
                    note
                });
            } else {
                addFallback(itemKey, fallbackName || itemKey, qty, "шт", groupOverride || "ONLY",
                    (note || "") + " (позиція/ціна не знайдена в only.data.json)");
            }
        }

        function addPermoKit(pointsTotal){
            const permoNote = "Стяжка Permo для панелей 25 мм (кришка/дно)";
            const addPermo = (code, fallbackName, qty) => {
                const it = getItemByIdOrCode(db, code);
                if (it) {
                    const pu = eurPrice(it);
                    items.push({
                        id: it.id || code,
                        code: it.code || code,
                        name: it.name_ua || it.name || fallbackName,
                        qtyPieces: qty,
                        unit: it.unit || "шт",
                        pieceLenMm: null,
                        sell_type: it.sell_type || it.sellType || "PCS",
                        priceEur: pu,
                        cutInfo: "—",
                        qtyPay: qty,
                        sumEur: qty * pu,
                        bars: null,
                        offcut: null,
                        group: it.group || "PERMO",
                        note: permoNote
                    });
                } else {
                    addFallback(code, `${fallbackName} (Permo)`, qty, "шт", "PERMO",
                        permoNote + " — додайте позицію в only.data.json, щоб підтягнулась ціна.");
                }
            };

            addPermo("B010ZZ0001409", "Вставка/камера Permo", pointsTotal);
            addPermo("GR01ZZ00010M8", "Гайка Permo M8", pointsTotal);
            addPermo("TF02FZ0000736", "Стяжка Permo (шпилька)", pointsTotal);
        }

        // Рахуємо vano/секції: у frameMode їх = numSpans, ширина vano = spanW
        const sectionsCount = frameMode ? numSpans : 1;
        const Lv = frameMode ? spanW : W;   // L_vano
        const Hmont = H;                    // H_montante

        // 1) Дно + кришка 25 мм (м²) + Permo (не залежить від задньої стінки)
        if (topBottom25) {
            const panelAreaOne = (W * D) / 1e6;       // м² однієї панелі
            const panelsM2 = panelAreaOne * 2;        // 2 панелі: дно + кришка
            addMaterialM2(
                "PANEL_25_MM2",
                panelsM2,
                "ДСП/МДФ 25 мм (м²)",
                `Розмір 1 шт: ${W}×${D} мм · К-сть: 2 шт · Разом: ${eur(panelsM2)} м²`
            );


            // Permo: 4 точки на панель у рамці; 2 панелі => 8 точок/рамка
            const permoPointsPerPanel = 4;
            const permoPointsTotal = numFrames * 2 * permoPointsPerPanel;
            addPermoKit(permoPointsTotal);
        }

        // 2) Задня стінка — ПО СЕКЦІЯХ (catalog dims)
        if (backPanelType === "opaque8") {
            const backH = Hmont - 38;
            const backW = Lv + 16;
            const oneM2 = (backH * backW) / 1e6;
            rearAreaM2 = oneM2 * sectionsCount;

            addMaterialM2("PANEL_BACK_8_MM2", rearAreaM2, "Задня стінка 8 мм (MDF/HDF) (м²)",
                `Спинка 8 мм: ${sectionsCount}×(Lv+16)×(H-38) = ${backW}×${backH} мм → ${eur(rearAreaM2)} м²`);
        }

        if (backPanelType === "glass6") {
            const backH = Hmont - 38;
            const backW = Lv + 11;
            const oneM2 = (backH * backW) / 1e6;
            rearAreaM2 = oneM2 * sectionsCount;

            addMaterialM2("GLASS_6_MM2", rearAreaM2, "Скло 6 мм (м²)",
                `Спинка скло 6 мм: ${sectionsCount}×(Lv+11)×(H-38) = ${backW}×${backH} мм → ${eur(rearAreaM2)} м²`);
            // === Glass price for back glass 6mm (tempered) ===
            if (glassSupplier === "BUSEL") {
                const b6 = calcBuselForPanel({ wMm: backW, hMm: backH, qty: sectionsCount, thicknessMm: 6, glassItemId: (buselBackGlassId || "BUSEL_CHINA_FLOAT_CLEAR_6_RIZKA"), temperMinType: "float" });
                if (b6){
                    const sumEur6 = b6.mtRetailUAH / Math.max(0.0001, b6._eurRate);
                    const effEurM26 = sumEur6 / Math.max(0.0001, (b6.billingArea * b6.qty));
                    setRowPriceByCode(
                        "GLASS_6_MM2",
                        effEurM26,
                        sumEur6,
                        `Busel v3 гарт.: ${b6.qty} шт · bill=${b6.billingArea.toFixed(3)}м² · kArea=${b6.kArea} · kBatch=${b6.kBatch} · min=${b6.temperMinUAH} грн`
                    );
                }
            } else {
                const a6 = calcAbstractForPanel({ wMm: backW, hMm: backH, qty: sectionsCount, thicknessMm: 6, glassItemId: (abstractBackGlassId || "ABS_FLOAT_6"), abs: abstract });
                if (a6){
                    const sumEur6 = a6.netUAH / Math.max(0.0001, EUR_RATE);
                    const effEurM26 = sumEur6 / Math.max(0.0001, a6.totalArea);
                    setRowPriceByCode(
                        "GLASS_6_MM2",
                        effEurM26,
                        sumEur6,
                        `Abstract гарт.+полір.: ${a6.q} шт · A=${a6.totalArea.toFixed(3)}м² · L=${a6.edgeLm.toFixed(2)}м`
                    );
                }
            }

        }

        // 3) Бокові панелі (скло в паз 4 мм) — ПО СЕКЦІЯХ (catalog dims)
        const sidesCount = (sideGlass === "both") ? 2 : ((sideGlass === "left" || sideGlass === "right") ? 1 : 0);

        if (sidesCount > 0) {
            const sideH = Hmont;        // catalog: Hmontante = Hvetro
            const sideW = D - 3.5;      // catalog: Lfianco - 3.5mm

            // кількість деталей (по секціях + по сторонах)
            const pieces = sectionsCount * sidesCount;

            // площа
            const oneM2 = (sideH * sideW) / 1e6;     // м² однієї боковини (1 шт)
            sideAreaM2 = oneM2 * pieces;             // загальна площа

            // ✅ ВИВІД РОЗМІРУ (мм) + КІЛЬКОСТІ (шт)
            addMaterialM2(
                "GLASS_4_MM2",
                sideAreaM2,
                "Скло 4 мм (м²)",
                `Розмір 1 шт: ${sideH.toFixed(1)}×${sideW.toFixed(1)} мм · К-сть: ${pieces} шт · Разом: ${eur(sideAreaM2)} м²`
            );
            // === Glass price for side glass 4mm (tempered) ===
            if (glassSupplier === "BUSEL") {
                const b4 = calcBuselForPanel({ wMm: sideW, hMm: sideH, qty: pieces, thicknessMm: 4, glassItemId: (buselSideGlassId || "BUSEL_FLOAT_CLEAR_4_RIZKA"), temperMinType: "float" });
                if (b4){
                    const sumEur4 = b4.mtRetailUAH / Math.max(0.0001, b4._eurRate);
                    const effEurM24 = sumEur4 / Math.max(0.0001, (b4.billingArea * b4.qty));
                    setRowPriceByCode(
                        "GLASS_4_MM2",
                        effEurM24,
                        sumEur4,
                        `Busel v3 гарт.: ${b4.qty} шт · bill=${b4.billingArea.toFixed(3)}м² · kArea=${b4.kArea} · kBatch=${b4.kBatch} · min=${b4.temperMinUAH} грн`
                    );
                }
            } else {
                const a4 = calcAbstractForPanel({ wMm: sideW, hMm: sideH, qty: pieces, thicknessMm: 4, glassItemId: (abstractSideGlassId || "ABS_FLOAT_4"), abs: abstract });
                if (a4){
                    const sumEur4 = a4.netUAH / Math.max(0.0001, EUR_RATE);
                    const effEurM24 = sumEur4 / Math.max(0.0001, a4.totalArea);
                    setRowPriceByCode(
                        "GLASS_4_MM2",
                        effEurM24,
                        sumEur4,
                        `Abstract гарт.+полір.: ${a4.q} шт · A=${a4.totalArea.toFixed(3)}м² · L=${a4.edgeLm.toFixed(2)}м`
                    );
                }
            }

            // ✅ PIATTO — 1 шт на кожну боковину (тобто на кожну деталь)
            addMaterialPCS("PIATTO_25x2",  pieces, "Пластина PIATTO-25x2",  "1 шт на боковину (по секціях)", "ONLY");
            addMaterialPCS("PIATTO_25x10", pieces, "Пластина PIATTO-25x10", "1 шт на боковину (по секціях)", "ONLY");
        }


        // ====== Cutting plans per BAR item ======

        const cutsByBar = {};
        items.forEach(r => {
            if (r.sell_type === "BAR" && r.pieceLenMm) {
                if (!cutsByBar[r.id]) cutsByBar[r.id] = [];
                for (let i = 0; i < r.qtyPieces; i++) cutsByBar[r.id].push(r.pieceLenMm);
            }
        });

        const barPlans = {};
        Object.keys(cutsByBar).forEach(id => {
            barPlans[id] = packCutsFFD(cutsByBar[id], barLenEff, kerfMm);
        });

        // Fill BAR rows: bars/offcut/pay
        items.forEach(r => {
            if (r.sell_type === "BAR" && r.pieceLenMm) {
                const plan = barPlans[r.id];
                r.bars = plan.barsCount;
                r.offcut = plan.offcutTotal;
                r.qtyPay = paymentUnitsForPlan(plan); // 0.5/1 per bar
                r.cutInfo = formatCutPlanWithPay(plan);
                r.sumEur = r.qtyPay * r.priceEur; // ціна за палку * оплата в палках
            } else {
                r.qtyPay = r.qtyPieces;
                r.sumEur = r.qtyPieces * r.priceEur;
                r.cutInfo = "—";
            }
        });

        const totalEur = items.reduce((s, r) => s + (r.sumEur || 0), 0);
        const barsTotal = Object.values(barPlans).reduce((s, p) => s + p.barsCount, 0);
        const offcutTotal = Object.values(barPlans).reduce((s, p) => s + p.offcutTotal, 0);
        const payBarsTotal = items
            .filter(r => r.sell_type === "BAR")
            .reduce((s, r) => s + (r.qtyPay || 0), 0);

        return { items, totalEur, barsTotal, offcutTotal, barLen, barLenEff, payBarsTotal, trimEachSide, rearAreaM2, sideAreaM2, nHor, nShelves, shelfType, sideGlass, colorWarnings };
    }

    // ====== render ======
    
    function render(spec) {
        const kpi = document.getElementById('kpi');
        const rearTxt = (spec.rearAreaM2 && spec.rearAreaM2 > 0) ? `${eur(spec.rearAreaM2)} м²` : "—";
        const sideTxt = (spec.sideAreaM2 && spec.sideAreaM2 > 0) ? `${eur(spec.sideAreaM2)} м²` : "—";

        let kpiHtml = ""
          + `<span class="chip"><b>Разом:</b> ${eur(spec.totalEur)} €</span>`
          + `<span class="chip"><b>Палки (факт):</b> ${spec.barsTotal} шт</span>`
          + `<span class="chip"><b>Оплата (0.5/1):</b> ${eur(spec.payBarsTotal)} пал.</span>`
          + `<span class="chip"><b>Залишок:</b> ${spec.offcutTotal} мм</span>`
          + `<span class="chip"><b>Корисна довжина:</b> ${spec.barLenEff} мм</span>`
          + `<span class="chip"><b>Горизонталі:</b> ${spec.nHor} шт</span>`
          + `<span class="chip"><b>Задня стінка:</b> ${rearTxt}</span>`
          + `<span class="chip"><b>Бокове скло:</b> ${sideTxt}</span>`;

        if (spec.colorWarnings && spec.colorWarnings.length) {
            kpiHtml += spec.colorWarnings.map(t =>
                `<span class="chip" style="background:rgba(245,158,11,.12)"><b>⚠</b> ${t}</span>`
            ).join("");
        }

        kpi.innerHTML = kpiHtml;

        const tbody = document.querySelector('#tbl tbody');
        tbody.innerHTML = '';
        spec.items.forEach(r => {
            const tr = document.createElement('tr');
            const detailsCell =
                `<b>${r.qtyPieces}</b>` +
                (r.note ? `<div class="muted small">${r.note}</div>` : "") +
                ((r.sell_type === "BAR" && r.pieceLenMm)
                    ? `<div class="muted small">${eur(r.qtyPay || 0)} пал. до оплати</div>`
                    : "") + ((r.cutInfo && r.cutInfo !== "—") ? `<div class="cutMobile muted small">${r.cutInfo}</div>` : "");
            tr.innerHTML = `
        <td><b>${r.code || r.id}</b></td>
        <td>${(r.name || r.name_ua || '')}<div class="muted small">${r.unit}</div></td>
        <td>${detailsCell}</td>
        <td class="cutCell">${r.cutInfo || '—'}</td>
        <td>${eur(r.priceEur)}</td>
        <td><b>${eur(r.sumEur || 0)}</b></td>
      `;
            tbody.appendChild(tr);
        });
    }


    // ====== CSV ======
    function toCSV(spec) {
        const lines = [];
        lines.push(["Код","Найменування","Деталі","Оплата (пал.)","Одиниця","Ціна EUR","Сума EUR","Опис різки"].join(";"));
        spec.items.forEach(r => {
            lines.push([
                (r.code || r.id),
                (r.name || "").replaceAll(";", ","),
                r.qtyPieces,
                (r.sell_type === "BAR" ? eur(r.qtyPay || 0) : ""),
                r.unit || "шт",
                eur(r.priceEur || 0),
                eur(r.sumEur || 0),
                (r.cutInfo || "").replaceAll(";", ",")
            ].join(";"));
        });
        return lines.join("\n");
    }
    function download(filename, text) {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([text], {type: 'text/csv;charset=utf-8;'}));
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    // ====== W range validation (MVP-2) ======
    function getWRange(shelfType){
        if (shelfType === "lait") return {min: 600, max: 1000, label: "LAIT (600–1000 мм)"};
        return {min: 600, max: 900, label: "ДСП/МДФ (600–900 мм)"};
    }
    function updateWRangeUI(W, shelfType, frameMode){
    const warn = document.getElementById("wRangeWarn");
    const r = getWRange(shelfType);
    if (!warn) return;

    if (frameMode){
        const numSpans = Math.max(1, Math.ceil(W / r.max));
        const spanW = Math.ceil(W / numSpans);

        warn.style.display = "block";
        if (W < r.min){
            warn.innerHTML = `⚠️ Ширина W = <b>${W}</b> мм менша за мінімум для полиць: <b>${r.min}</b> мм.`;
        } else if (spanW < r.min){
            warn.innerHTML = `⚠️ Режим рамок: ширина прольоту <b>${spanW}</b> мм менша за мінімум <b>${r.min}</b> мм.`;
        } else {
            warn.innerHTML = `ℹ️ Режим рамок: <b>${numSpans}</b> прольоти (~<b>${spanW}</b> мм) · рамок: <b>${numSpans+1}</b> · полиці: <b>${r.label}</b>.`;
        }
        return;
    }

    if (W < r.min || W > r.max){
        warn.style.display = "block";
        warn.innerHTML = `⚠️ Ширина W = <b>${W}</b> мм виходить за робочу ширину для полиць: <b>${r.label}</b>.`;
    } else {
        warn.style.display = "none";
        warn.innerHTML = "";
    }
}






// ===== LAIT handoff (ONLY -> LAIT Lite) =====


(function initLaitHandoffOnce(){
    if (window.__laitHandoffInited) return;
    window.__laitHandoffInited = true;
    const openLaitBtn = document.getElementById('openLaitBtn');
    const laitHint    = document.getElementById('laitHint');
     // Повертає "кількість прольотів" (рамок по ширині) за твоїм бізнес-правилом
    function getSpansCount(W, shelfType, frameMode){
        if (!frameMode) return 1;
         // правило: ДСП <= 900, LAIT <= 1000 (як у твоїх підказках)
        const maxSpan = (shelfType === 'lait') ? 1000 : 900;
        return Math.max(1, Math.ceil(W / maxSpan));
    }
     // Ширина одного прольоту (Lvano). Тут важливо: беремо ширину W і ділимо на проліт.
    // Якщо пізніше додаси "торці/зазори" — правиш тут в одному місці.
    function getSectionClearWidthMm(W, spansCount){
        return W / spansCount;
    }
     function getEurRateSafe(){
        // беремо курс з інпута (якщо є), інакше localStorage, інакше 50.0
        const domVal = Number(document.getElementById('eurRateInput')?.value);
        if (Number.isFinite(domVal) && domVal > 0) return domVal;
        const v = Number(localStorage.getItem('eurRate') || 50.0);
        return Number.isFinite(v) ? v : 50.0;
    }
     function openLaitCalcFromOnly(){
        const W = parseFloat(document.getElementById('W').value || '0');
        const D = parseFloat(document.getElementById('D').value || '0');
        const shelfType    = document.getElementById('shelfType').value;
        const shelvesCount = parseInt(document.getElementById('shelvesCount').value || '0', 10);
        const frameMode    = !!document.getElementById('frameMode')?.checked;
         if (W <= 0 || D <= 0) { alert('Заповни W та D'); return; }
        if (shelvesCount <= 0) { alert('Вкажи кількість полиць > 0'); return; }
        if (shelfType !== 'lait') { alert('LAIT доступний лише коли "Тип полиць" = LAIT'); return; }
         const spansCount = getSpansCount(W, shelfType, frameMode);
        const Lv = getSectionClearWidthMm(W, spansCount);
        const eurRate = getEurRateSafe();
         const url =
            `lait-lite.backup.html` +
            `?eur=${encodeURIComponent(eurRate.toFixed(2))}` +
            `&len=${encodeURIComponent(Math.round(Lv))}` +
            `&dep=${encodeURIComponent(Math.round(D))}` +
            `&qty=${encodeURIComponent(shelvesCount)}`;
         window.open(url, '_blank');
    }
     function updateLaitUI(){
        const shelfType    = document.getElementById('shelfType')?.value;
        const shelvesCount = parseInt(document.getElementById('shelvesCount')?.value || '0', 10);
        const W = parseFloat(document.getElementById('W')?.value || '0');
        const D = parseFloat(document.getElementById('D')?.value || '0');
        const frameMode = !!document.getElementById('frameMode')?.checked;
         const show = shelfType === 'lait';
        if (openLaitBtn) openLaitBtn.style.display = show ? 'inline-flex' : 'none';
         if (laitHint){
            if (!show) { laitHint.textContent = ''; return; }
             const spansCount = getSpansCount(W, shelfType, frameMode);
            const Lv = (W > 0 ? getSectionClearWidthMm(W, spansCount) : 0);
             laitHint.textContent =
                `LAIT рахуємо в окремому калькуляторі: ` +
                `передамо проліт (≈${Math.round(Lv)} мм) + глибину (${Math.round(D)} мм) + к-сть полиць (${shelvesCount}).`;
        }
    }
     window.__addLaitTotalRowIfAny = function(rows){
        const totalEur = Number(localStorage.getItem("ONLY_LAIT_TOTAL_EUR") || 0);
        if (!totalEur) return 0;
         const meta = JSON.parse(localStorage.getItem("ONLY_LAIT_META") || "{}");
         // прибрати дубль при повторному перерахунку
        for (let i = rows.length - 1; i >= 0; i--) {
            if (rows[i]?.code === "LAIT_TOTAL") rows.splice(i, 1);
        }
         rows.push({
            code: "LAIT_TOTAL",
            name: "Полиці LAIT (підсумок з LAIT калькулятора)",
            qtyPieces: 1,
            unit: "компл.",
            sell_type: "PCS",
            priceEur: totalEur,
            sumEur: totalEur,
            group: "LAIT",
            note: meta?.lenMm ? `L=${meta.lenMm} мм · D=${meta.depMm} мм · Qty=${meta.qty}` : ""
        });
         return totalEur;
    };


// attach once
    if (openLaitBtn) openLaitBtn.addEventListener('click', openLaitCalcFromOnly);
     document.getElementById('shelfType')?.addEventListener('change', updateLaitUI);
    document.getElementById('shelvesCount')?.addEventListener('input', updateLaitUI);
    document.getElementById('W')?.addEventListener('input', updateLaitUI);
    document.getElementById('D')?.addEventListener('input', updateLaitUI);
    document.getElementById('frameMode')?.addEventListener('change', updateLaitUI);
     updateLaitUI();
    document.getElementById('glassSupplier')?.addEventListener('change', updateGlassSupplierUI);
    updateGlassSupplierUI();
})();


// ====== events ======
    async function calculate() {
        const db = await loadDB();
        const busel = await loadBusel();
        const abstract = await loadAbstract();
        updateGlassSupplierUI();
        const H = Number(document.getElementById('H').value);
        const W = Number(document.getElementById('W').value);
        const D = Number(document.getElementById('D').value);
        const eurRate = Number(document.getElementById('eurRateInput')?.value || localStorage.getItem('eurRate') || 50.0);
        try { localStorage.setItem('eurRate', String(eurRate)); } catch(e) {}

        // Sync Busel engine config with current EUR rate
        if (window.GlassEngine && typeof GlassEngine.setBuselConfig === "function") {
            const prev = GlassEngine.BUSEL_CFG || {};
            GlassEngine.setBuselConfig({ ...prev, eurRate: eurRate });
        }

        const trimEachSide = Number(document.getElementById('trimEachSide').value || 0);
        const backPanelType = document.getElementById('backPanelType').value; // none | opaque8 | glass6
        const buselBackGlassId = document.getElementById('buselBackGlassId')?.value || "BUSEL_CHINA_FLOAT_CLEAR_6_RIZKA";
        const buselSideGlassId = document.getElementById('buselSideGlassId')?.value || "BUSEL_FLOAT_CLEAR_4_RIZKA";
        const isLed = (document.getElementById('isLed')?.checked ?? false);
        const colorCode = document.getElementById('colorCode').value;

        // ===== LAIT handoff (ONLY -> LAIT Lite) =====
// IMPORTANT: ONLY не має інпутів sectionsCount/eurRate, тому НЕ читаємо їх з DOM.


if (!H || !W || !D) throw new Error("Заповни H/W/D.");
        if (H < 300 || W < 300 || D < 200) throw new Error("Нереальні габарити. Перевір H/W/D.");

        const shelfType = document.getElementById('shelfType').value;
        const shelvesCount = Number(document.getElementById('shelvesCount').value || 0);
        const sideGlass = document.getElementById('sideGlass').value;
        const glassSupplier = (document.getElementById('glassSupplier')?.value) || 'ABSTRACT';
        const abstractSideGlassId = (document.getElementById('abstractSideGlassId')?.value) || 'ABS_FLOAT_4';
        const abstractBackGlassId = (document.getElementById('abstractBackGlassId')?.value) || 'ABS_FLOAT_6';

        const frameMode = (document.getElementById('frameMode')?.checked ?? false);
        const topBottom25 = document.getElementById('topBottom25')?.checked ?? true;

        updateWRangeUI(W, shelfType, frameMode);

        const spec = buildSpec(db, { H, W, D, backPanelType, isLed, trimEachSide, colorCode, shelfType, shelvesCount, sideGlass, glassSupplier, buselBackGlassId, buselSideGlassId, abstractBackGlassId, abstractSideGlassId, frameMode, topBottom25, busel, abstract, eurRate });
// + LAIT total (якщо є з lait-lite.html)
try {
    const laitAdd = window.__addLaitTotalRowIfAny ? window.__addLaitTotalRowIfAny(spec.items) : 0;
    if (laitAdd) {
        spec.totalEur = (spec.totalEur || 0) + laitAdd;
    }
} catch (e) {
    console.warn("LAIT total handoff skipped:", e);
}

        window.__onlySpec = spec;
        render(spec);
    }

    document.getElementById('btnCalc').addEventListener('click', () => {
        calculate().catch(err => alert(err.message || String(err)));
    });

    document.getElementById('btnCsv').addEventListener('click', () => {
        const spec = window.__onlySpec;
        if (!spec) return alert("Спочатку натисни «Розрахувати».");
        download("ONLY_spec.csv", toCSV(spec));
    });

        // auto recalc on input change
    [
        "H","W","D","eurRateInput","trimEachSide",
        "backPanelType","buselBackGlassId",
        "sideGlass","buselSideGlassId",
        "isLed","colorCode",
        "shelfType","shelvesCount",
        "frameMode","topBottom25"
    ].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', () => calculate().catch(()=>{}));
        el.addEventListener('change', () => calculate().catch(()=>{}));
    });


    // initial
    calculate().catch(e=>{ console.error(e); alert(e?.message || String(e)); });

    // ===== Client / Manager mode + Telegram =====
    let currentMode = localStorage.getItem("ONLY_MODE") || "client";

    const elModeLabel = document.getElementById("currentModeLabel");
    const elManagerBtn = document.getElementById("managerToggleBtn");
    const elManagerDetails = document.getElementById("managerDetails");
    const elClientSummary = document.getElementById("clientSummary");

    function applyModeUI(){
        const isManager = currentMode === "manager";
        if (elModeLabel) elModeLabel.textContent = "Режим: " + (isManager ? "менеджер" : "клієнт");
        if (elManagerBtn) elManagerBtn.textContent = isManager ? "Клієнт" : "Менеджер";
        if (elManagerDetails) elManagerDetails.style.display = isManager ? "" : "none";
        if (document.getElementById("btnCsv")) document.getElementById("btnCsv").style.display = isManager ? "" : "none";
    }

    if (elManagerBtn){
        elManagerBtn.addEventListener("click", () => {
            currentMode = (currentMode === "manager") ? "client" : "manager";
            localStorage.setItem("ONLY_MODE", currentMode);
            applyModeUI();
        });
    }

    // Keep a lightweight summary for client
    function updateClientSummary(spec){
        if(!elClientSummary) return;
        if(!spec){ elClientSummary.textContent = "Натисни «Розрахувати» — тут буде підсумок."; return; }
        const eurRate = Number(document.getElementById("eurRateInput")?.value || 50);
        const totalUah = Math.round((spec.totalEur || 0) * eurRate);
        elClientSummary.innerHTML = `Разом: <b>${(spec.totalEur||0).toFixed(2)} €</b> (~ <b>${totalUah.toLocaleString('uk-UA')} грн</b>) · H=${spec.H} · W=${spec.W} · D=${spec.D}`;
    }

    // Telegram send
    const TELEGRAM_API_URL = "https://mt-volpato.vercel.app/api/telegram";
    const TELEGRAM_FORM_SECRET = "mtx-volpato-2025"; // <-- якщо у файлі вже є секрет — заміни на нього

    async function sendToTelegram(){
        const spec = window.__onlySpec;
        if(!spec) return alert("Спочатку натисни «Розрахувати».");
        const firstName = (document.getElementById("contactFirstName")?.value || "").trim();
        const lastName  = (document.getElementById("contactLastName")?.value || "").trim();
        const phone     = (document.getElementById("contactPhone")?.value || "").trim();
        const eurRate   = Number(document.getElementById("eurRateInput")?.value || 50);

        const totalUah = Math.round((spec.totalEur || 0) * eurRate);

        const modeLine = (currentMode === "manager") ? "*менеджер*" : "*клієнт*";
        const contactLine = `👤 ${firstName || "—"} ${lastName || ""}\n📞 ${phone || "—"}`;

        const glassLine = `🪟 Скло: ${document.getElementById("glassSupplier")?.value || "—"}`;

        let text = `📨 Нова заявка: ONLY\n\n${contactLine}\n\n🔁 Режим: ${modeLine}\n\nГабарити: *${spec.W}×${spec.H}×${spec.D} мм*\n${glassLine}\n\n💰 Сума: *${(spec.totalEur||0).toFixed(2)} €* (~ *${totalUah.toLocaleString('uk-UA')} грн*)\n\n`;

        // CSV-like lines
        text += "```\nКод; Назва; Кількість; Ціна €/од; Сума €\n";
        for(const r of (spec.items||[])){
            const code = (r.code||"").toString();
            const name = (r.name||"").toString().replace(/\s+/g," ").trim();
            const qty  = (r.qtyPieces ?? r.qty ?? "").toString();
            const p    = (r.priceEur ?? "").toString();
            const s    = (r.sumEur ?? "").toString();
            text += `${code}; ${name}; ${qty}; ${p}; ${s}\n`;
        }
        text += "```";

        const payload = { secret: TELEGRAM_FORM_SECRET, text };

        const res = await fetch(TELEGRAM_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });
        if(!res.ok){
            const t = await res.text().catch(()=> "");
            throw new Error("Telegram error: " + res.status + " " + t);
        }
        alert("Заявку надіслано ✅");
    }

    const sendBtn = document.getElementById("sendToTelegramBtn");
    if(sendBtn){
        sendBtn.addEventListener("click", () => {
            sendToTelegram().catch(err => alert(err.message || String(err)));
        });
    }

    // Hook into render to refresh client summary
    const __renderOrig = render;
    render = function(spec){
        __renderOrig(spec);
        updateClientSummary(spec);
        applyModeUI();
    };

    applyModeUI();

</script>
</body>
</html>
